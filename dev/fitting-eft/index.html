<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fitting an Electronic Friction Tensor · ACEds.jl</title><meta name="title" content="Fitting an Electronic Friction Tensor · ACEds.jl"/><meta property="og:title" content="Fitting an Electronic Friction Tensor · ACEds.jl"/><meta property="twitter:title" content="Fitting an Electronic Friction Tensor · ACEds.jl"/><meta name="description" content="Documentation for ACEds.jl."/><meta property="og:description" content="Documentation for ACEds.jl."/><meta property="twitter:description" content="Documentation for ACEds.jl."/><meta property="og:url" content="https://ACEsuit.github.io/ACEds.jl/fitting-eft/"/><meta property="twitter:url" content="https://ACEsuit.github.io/ACEds.jl/fitting-eft/"/><link rel="canonical" href="https://ACEsuit.github.io/ACEds.jl/fitting-eft/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ACEds.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../installation/">Installation Guide</a></li><li><a class="tocitem" href="../overview/">Overview</a></li></ul></li><li><span class="tocitem">Workflow Examples</span><ul><li class="is-active"><a class="tocitem" href>Fitting an Electronic Friction Tensor</a><ul class="internal"><li><a class="tocitem" href="#Load-Electronic-Friction-Tensor-Data"><span>Load Electronic Friction Tensor Data</span></a></li><li><a class="tocitem" href="#Specify-the-Friction-Model"><span>Specify the Friction Model</span></a></li><li><a class="tocitem" href="#Set-up-the-Training-Pipeline"><span>Set up the Training Pipeline</span></a></li><li><a class="tocitem" href="#Running-the-Optimizer"><span>Running the Optimizer</span></a></li><li><a class="tocitem" href="#Evaluating-the-Friction-Model"><span>Evaluating the Friction Model</span></a></li></ul></li><li><a class="tocitem" href="../fitting-mbdpd/">Fitting a Dissipative Particle Dynamics Friction Model</a></li></ul></li><li><span class="tocitem">Function Manual</span><ul><li><a class="tocitem" href="../function-manual/">Function Manual</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Workflow Examples</a></li><li class="is-active"><a href>Fitting an Electronic Friction Tensor</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fitting an Electronic Friction Tensor</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ACEsuit/ACEds.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ACEsuit/ACEds.jl/blob/main/docs/src/fitting-eft.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Fitting-an-Electronic-Friction-Tensor"><a class="docs-heading-anchor" href="#Fitting-an-Electronic-Friction-Tensor">Fitting an Electronic Friction Tensor</a><a id="Fitting-an-Electronic-Friction-Tensor-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-an-Electronic-Friction-Tensor" title="Permalink"></a></h1><p>In this workflow example we demonstrate how <code>ACEds.jl</code> can be used to fit a simple 6 x 6 Electronic friction tensor modeling the non-adiabitic interactions of a hydrogen-atom on a copper surface. </p><h2 id="Load-Electronic-Friction-Tensor-Data"><a class="docs-heading-anchor" href="#Load-Electronic-Friction-Tensor-Data">Load Electronic Friction Tensor Data</a><a id="Load-Electronic-Friction-Tensor-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-Electronic-Friction-Tensor-Data" title="Permalink"></a></h2><p>We first use the function <a href>load_h5fdata</a> to load the data of friction tensors from a <a href>custom-formated</a> hdf5 file and convert the data to the internal data format [FrictionData].</p><pre><code class="language-julia hljs">using ACEds
# Load data 
rdata = ACEds.DataUtils.load_h5fdata( &quot;./test/test-data-100.h5&quot;); 
# Specify size of training and test data
n_train = Int(ceil(.8 * length(rdata)))
n_test = length(rdata) - n_train
# Partition data into train and test set and convert the data 
fdata = Dict(&quot;train&quot; =&gt; FrictionData.(rdata[1:n_train]), 
            &quot;test&quot;=&gt; FrictionData.(rdata[n_train+1:end]));</code></pre><h2 id="Specify-the-Friction-Model"><a class="docs-heading-anchor" href="#Specify-the-Friction-Model">Specify the Friction Model</a><a id="Specify-the-Friction-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Specify-the-Friction-Model" title="Permalink"></a></h2><p>Next, we specify the matrix models that will make up our friction model. In this case we only specify the single matrix model <code>m_equ</code>, which being of the type <code>RWCMatrixModel</code> is based on a row-wise coupling. </p><pre><code class="language-julia hljs">property = EuclideanMatrix()
species_friction = [:H]
species_env = [:Cu]
m_equ = RWCMatrixModel(property, species_friction, species_env;
    species_substrat = [:Cu],
    rcut = 5.0, 
    maxorder = 2, 
    maxdeg = 5,
);</code></pre><p>The first argument, <code>property</code>, of the constructor, <code>RWCMatrixModel</code>, specifies the equivariance symmetry of blocks. Here, <code>property</code> is of type <code>EuclideanMatrix</code> specifying each block to  transform like an Euclidean Matrix. In this modeling application, only hydrogen atoms feel friction, which we specify by setting the second argument <code>species_friction</code> to <code>[:H]</code>. Yet, the friction felt by an hydrogen atom is affected by the presence of both hydrogen atoms and copper atoms in its vicinty, which we specify by setting <code>species_env</code> to <code>[:H, :Cu]</code>. Furthermore, the physics is such that hydrogen models only feel friction if they are in contact with the metal surface. We specify this by setting <code>species_substrat = [:Cu]</code>. For further details and information on the remaining optional arguments see the docomentation of the constructor of <a href>RWCMatrixModel</a>.</p><p>Next we build a friction model from the matrix model(s),</p><pre><code class="language-julia hljs">fm= FrictionModel((mequ=m_equ,)); #fm= FrictionModel((cov=m_cov,equ=m_equ));</code></pre><p>Here, the <code>mequ</code> serves as the &quot;ID&quot; of the friction model <code>m_equ</code> within the friction model. The function <code>get_ids</code> returns the model IDs Wof all matrix model makig up a friction model, i.e.,</p><pre><code class="nohighlight hljs">model_ids = get_ids(fm)</code></pre><h2 id="Set-up-the-Training-Pipeline"><a class="docs-heading-anchor" href="#Set-up-the-Training-Pipeline">Set up the Training Pipeline</a><a id="Set-up-the-Training-Pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-Training-Pipeline" title="Permalink"></a></h2><p>To train our model we first extract the parameters from the friction model, which we use to initialize a structure of type <code>FluxFrictionModel</code>, which serves as a wrapper for the parameters</p><pre><code class="language-julia hljs">c=params(fm)                                
ffm = FluxFrictionModel(c)</code></pre><p>Next, the function <code>flux_assemble</code> is used to prepare data for training. This includes evaluating the ACE-basis functions of the matrix models in <code>fm</code> on all configurations in the data set. Since the loss function of our model is quartic polynomial in the parameters, we don&#39;t need to reevaluate the ACE-basis functions at later stages of the training process.</p><pre><code class="language-julia hljs">flux_data = Dict( &quot;train&quot;=&gt; flux_assemble(fdata[&quot;train&quot;], fm, ffm; ),
                  &quot;test&quot;=&gt; flux_assemble(fdata[&quot;test&quot;], fm, ffm));</code></pre><p>Before starting the training we randomize the parameter values of our model and, if CUDA is available on our device, transform parameters to CUDA compatible <code>cuarrays</code>.</p><pre><code class="language-julia hljs">set_params!(ffm; sigma=1E-8)

using CUDA
cuda = CUDA.functional()

if cuda
    ffm = fmap(cu, ffm)
end</code></pre><p>Finally, we set up the optimizer and data loader, and import the loss functions <code>weighted_l2_loss</code>, which evaluates the training and test loss as</p><p class="math-container">\[\mathcal{L}(c) = \| \Gamma_{\rm true} - W \odot \Gamma_{\rm fit}(c) \|_2^2,\]</p><p>where <span>$\odot$</span> is the entry-wise Hademard product, and <span>$W$</span> is a weight matrix assembled during the call of <code>flux_assemble</code>.</p><pre><code class="language-julia hljs">opt = Flux.setup(Adam(1E-3, (0.99, 0.999)),ffm)
dloader = cuda ? DataLoader(flux_data[&quot;train&quot;] |&gt; gpu, batchsize=10, shuffle=true) : DataLoader(flux_data[&quot;train&quot;], batchsize=10, shuffle=true)
using ACEds.FrictionFit: weighted_l2_loss</code></pre><h2 id="Running-the-Optimizer"><a class="docs-heading-anchor" href="#Running-the-Optimizer">Running the Optimizer</a><a id="Running-the-Optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-Optimizer" title="Permalink"></a></h2><p>Then, we train the model taking 200 passes through the training data: </p><pre><code class="language-julia hljs">loss_traj = Dict(&quot;train&quot;=&gt;Float64[], &quot;test&quot; =&gt; Float64[])
epoch = 0
nepochs = 100
for _ in 1:nepochs
    epoch+=1
    @time for d in dloader
        ∂L∂m = Flux.gradient(weighted_l2_loss,ffm, d)[1]
        Flux.update!(opt,ffm, ∂L∂m)       # method for &quot;explicit&quot; gradient
    end
    for tt in [&quot;test&quot;,&quot;train&quot;]
        push!(loss_traj[tt], weighted_l2_loss(ffm,flux_data[tt]))
    end
    println(&quot;Epoch: $epoch, Abs avg Training Loss: $(loss_traj[&quot;train&quot;][end]/n_train)), Test Loss: $(loss_traj[&quot;test&quot;][end]/n_test))&quot;)
end
println(&quot;Epoch: $epoch, Abs Training Loss: $(loss_traj[&quot;train&quot;][end]), Test Loss: $(loss_traj[&quot;test&quot;][end])&quot;)
println(&quot;Epoch: $epoch, Avg Training Loss: $(loss_traj[&quot;train&quot;][end]/n_train), Test Loss: $(loss_traj[&quot;test&quot;][end]/n_test)&quot;)</code></pre><p>Once the training is complete we can extract the updated parameters from the wrapper <code>ffm</code> to parametrize the friction model. </p><pre><code class="language-julia hljs">c = params(ffm)
set_params!(fm, c)</code></pre><h2 id="Evaluating-the-Friction-Model"><a class="docs-heading-anchor" href="#Evaluating-the-Friction-Model">Evaluating the Friction Model</a><a id="Evaluating-the-Friction-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluating-the-Friction-Model" title="Permalink"></a></h2><p>The trained friction model can be used to evaluate the friction tensor <span>${\\bm \\Gamma}$</span> and diffusion coeccifient matrix <span>${\\bm \\Sigma}$</span> at configurations as follows </p><pre><code class="language-julia hljs">at = fdata[&quot;test&quot;][1].atoms # extract atomic configuration from the test set
Gamma(fm, at) # evaluate the friction tensor
Σ = Sigma(fm, at) # evaluate the diffusion coeffcient matrix</code></pre><p>To simulate a Langevin equation, typically, both the friction coefficient and the diffusion coefficient matrix must be evaluated. Instead of evaluating them seperately it is more efficient to first evaluate the diffusion coefficient matrix and then evaluate the friction tensor from the the pre-computed diffusion coefficient matrix:</p><pre><code class="language-julia hljs">Σ = Sigma(fm, at) # evaluate the diffusion coeffcient matrix
Gamma(fm, Σ) # compute the friction tensor from the pre-computeed diffusion coefficient matrix.</code></pre><p>The diffusion coefficient matrix <span>$\\Sigma$</span> can also be used to efficiently generate Gaussian pseudo random numbers <span>${\rm Normal}(0,{\bf \Gamma})$</span> as </p><pre><code class="language-julia hljs">R = randf(fm,Σ)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><a class="docs-footer-nextpage" href="../fitting-mbdpd/">Fitting a Dissipative Particle Dynamics Friction Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 30 October 2024 12:07">Wednesday 30 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
